Controllato ‚úÖ (event-four-you-siae-lettore-main 4.zip). Adesso il bridge C# √® impostato correttamente per fare CAdES-BES con libSIAEp7.dll e restituire p7mBase64.

Quello che va sistemato per evitare ancora ‚Äú.p7m‚Äù sbagliati √® nel layer Electron/relay (e lato Replit).

1) Bridge C# (SiaeBridge/Program.cs) ‚Äî OK

La funzione SignXml():
	‚Ä¢	prende xmlContent
	‚Ä¢	chiama CreateCAdESSignature(...) (PKCS#7/P7M via libSIAEp7.dll)
	‚Ä¢	ritorna JSON con:
	‚Ä¢	signature.p7mBase64
	‚Ä¢	format: CAdES-BES
	‚Ä¢	algorithm: SHA-256

‚úÖ Qui sei a posto.

‚∏ª

2) Desktop app Electron (desktop-app/main.js) ‚Äî DA CORREGGERE (importante)

In desktop-app/main.js c‚Äô√® ancora questa logica:

const signatureData = result.signature.p7mBase64 ? { ... } : { ... fallback XMLDSig ... };

üëâ Questo √® pericoloso perch√© se per qualunque motivo p7mBase64 manca, inviate XMLDSig (che poi qualcuno salva come .p7m ‚Üí file leggibile ‚Üí SIAE ignora).

‚úÖ Fix richiesto

Rimuovere il fallback e bloccare la firma se manca p7mBase64.

Sostituisci quel blocco con:

if (!result.signature?.p7mBase64) {
  relayWs.send(JSON.stringify({
    type: 'SIGNATURE_RESPONSE',
    requestId: signRequestId,
    payload: { success: false, error: 'Firma CAdES-BES fallita: p7mBase64 mancante' }
  }));
  return;
}

const signatureData = {
  p7mBase64: result.signature.p7mBase64,
  format: result.signature.format || 'CAdES-BES',
  algorithm: result.signature.algorithm || 'SHA-256',
  signedAt: result.signature.signedAt
};

‚úÖ Cos√¨ invii solo P7M vero, oppure fallisci chiaramente.

‚∏ª

3) Root Electron (main.js) ‚Äî quasi OK, ma togli xmlContent

Nel main.js root hai gi√† disabilitato il fallback (bene), per√≤ mandi ancora:

xmlContent: result.signature.xmlContent

Nel bridge non esiste pi√π xmlContent dentro signature, quindi √® undefined, ma pu√≤ confondere chi riceve.

‚úÖ Fix richiesto

Rimuovi xmlContent dalla payload inviata al relay:

const signatureData = {
  p7mBase64: result.signature.p7mBase64,
  format: result.signature.format || 'CAdES-BES',
  algorithm: result.signature.algorithm || 'SHA-256',
  signedAt: result.signature.signedAt
};


‚∏ª

4) Lato Replit (fondamentale) ‚Äî come salvare il file

Replit deve decodificare base64 ‚Üí bytes e scrivere in binario.

Node (Replit)

fs.writeFileSync(outPath, Buffer.from(p7mBase64, 'base64'));

‚ùå NON fare writeFileSync(outPath, p7mBase64, 'utf8') (crea file testo).

‚∏ª

Check rapido (senza OpenSSL)

Dopo aver salvato il .p7m:
	‚Ä¢	Aprilo con Blocco Note
	‚Ä¢	‚úÖ Deve essere illeggibile (caratteri strani)
	‚Ä¢	‚ùå Se vedi XML o base64, state salvando male

‚∏ª

In 1 riga: cosa deve sistemare per la firma
	1.	Eliminare il fallback XMLDSig in desktop-app/main.js
	2.	Inviare solo p7mBase64 (senza xmlContent)
	3.	Su Replit salvare il P7M decodificando base64 in bytes

Se vuoi, incollami qui il pezzo di codice Replit dove riceve SIGNATURE_RESPONSE e salva il file: ti dico esattamente la riga da cambiare.